local Chunker = require("lib.chunking.UTF8Chunker")

describe("chunking.UTF8Chunker", function()
    describe("function New", function()
        it("rejects lengths less than 1", function()
            assert.has.error(function() Chunker.New(0) end, "minimum length must be 1 or greater")
        end)
        it("creates a chunker with a minimum string length", function()
            local chunker = Chunker.New(1)
            assert.are_same(1, chunker.GetMinimumLength())
        end)
    end)
    describe("minimum length 1, function Chunk(str, maxChunks)", function ()
        ---@type UTF8ChunkerInstance
        local chunker = nil
        before_each(function()
            chunker = Chunker.New(1)
        end)
        it("chunks '' into {''} with maxChunks 1", function ()
            assert.are_same({''}, chunker.Chunk('', 1))
        end)
        it("chunks 'a' {'a'} with maxChunks 1", function ()
            assert.are_same({'a'}, chunker.Chunk('a', 1))
        end)
        it("chunks 'ab' into {'ab'} with maxChunks 1", function ()
            assert.are_same({'ab'}, chunker.Chunk('ab', 1))
        end)
        it("chunks 'ab' into {'a', 'b'} with maxChunks 2", function ()
            assert.are_same({'a', 'b'}, chunker.Chunk('ab', 2))
        end)
        it("chunks 'abc' into {'ab', 'c'} with maxChunks 2", function ()
            assert.are_same({'ab', 'c'}, chunker.Chunk('abc', 2))
        end)
        it("chunks 'abcd' into {'ab', 'cd'} with maxChunks 2", function ()
            assert.are_same({'ab', 'cd'}, chunker.Chunk('abcd', 2))
        end)
        it("chunks 'abcd' into {'ab', 'cd'} with maxChunks 3", function ()
            assert.are_same({'ab', 'cd'}, chunker.Chunk('abcd', 3))
        end)
        it("chunks 'abcde' into {'ab', 'cd', 'e'} with maxChunks 3", function ()
            assert.are_same({'ab', 'cd', 'e'}, chunker.Chunk('abcde', 3))
        end)
        it("chunks 'abcdefghi' into {'abc', 'def', 'ghi'} with maxChunks 3", function ()
            assert.are_same({'abc', 'def', 'ghi'}, chunker.Chunk('abcdefghi', 3))
        end)
        it("chunks multicode chars 'åäödefghi' into {'åäö', 'def', 'ghi'} with maxChunks 3", function ()
            assert.are_same({'åäö', 'def', 'ghi'}, chunker.Chunk('åäödefghi', 3))
        end)
        it("chunks multicode chars 'åååäääö' into {'ååå', 'äää', 'ö'} with maxChunks 3", function ()
            assert.are_same({'ååå', 'äää', 'ö'}, chunker.Chunk('åååäääö', 3))
        end)
        it("chunks multicode chars 'åååäääöö' into {'ååå', 'äää', 'öö'} with maxChunks 3", function ()
            assert.are_same({'ååå', 'äää', 'öö'}, chunker.Chunk('åååäääöö', 3))
        end)
        it("chunks multicode chars 'åååäääööö' into {'ååå', 'äää', 'ööö'} with maxChunks 3", function ()
            assert.are_same({'ååå', 'äää', 'ööö'}, chunker.Chunk('åååäääööö', 3))
        end)
        it("chunks 'Miðhraun is an Icelandic resort' into {'Miðhraun is an I', 'celandic resort'} with maxChunks 2", function ()
            assert.are_same({'Miðhraun is an I', 'celandic resort'}, chunker.Chunk('Miðhraun is an Icelandic resort', 2))
        end)
        it("chunks 'Miðhraun is an Icelandic resort' into {'Miðhraun is', ' an Iceland', 'ic resort'} with maxChunks 3", function ()
            assert.are_same({'Miðhraun is', ' an Iceland', 'ic resort'}, chunker.Chunk('Miðhraun is an Icelandic resort', 3))
        end)
        it("chunks 'Miðhraun is an Icelandic resort' into {'Miðh', 'raun', ' is ', 'an I', 'cela', 'ndic', ' res', 'ort'} with maxChunks 10", function ()
            assert.are_same({'Miðh', 'raun', ' is ', 'an I', 'cela', 'ndic', ' res', 'ort'}, chunker.Chunk('Miðhraun is an Icelandic resort', 10))
        end)
        it("chunks 'Miðhraun' (8 characters) into {'M', 'i', 'ð', 'h', 'r', 'a', 'u', 'n'} with maxChunks 10", function ()
            assert.are_same({'M', 'i', 'ð', 'h', 'r', 'a', 'u', 'n'}, chunker.Chunk('Miðhraun', 10))
        end)
    end)
    describe("minimum length 4, function Chunk(str, maxChunks)", function ()
        ---@type UTF8ChunkerInstance
        local chunker = nil
        before_each(function()
            chunker = Chunker.New(4)
        end)
        it("chunks 'Miðhraun' (8 characters) into {'Miðh', 'raun'} with maxChunks 10", function ()
            assert.are_same({'Miðh', 'raun'}, chunker.Chunk('Miðhraun', 10))
        end)
        it("chunks 'Miðhr' (5 characters) into {'Miðh', 'r'} with maxChunks 10", function ()
            assert.are_same({'Miðh', 'r'}, chunker.Chunk('Miðhr', 10))
        end)
        it("chunks 'Miðh' (4 characters) into {'Miðh'} with maxChunks 10", function ()
            assert.are_same({'Miðh'}, chunker.Chunk('Miðh', 10))
        end)
        it("chunks 'Mið' (3 characters) into {'Mið'} with maxChunks 10", function ()
            assert.are_same({'Mið'}, chunker.Chunk('Mið', 10))
        end)
        it("chunks 'Mi' (2 characters) into {'Mi'} with maxChunks 10", function ()
            assert.are_same({'Mi'}, chunker.Chunk('Mi', 10))
        end)
        it("chunks 'M' (1 character) into {'M'} with maxChunks 10", function ()
            assert.are_same({'M'}, chunker.Chunk('M', 10))
        end)
    end)
    -- Russian tests just to make sure
    describe("minimum length 5, function Chunk(str, maxChunks)", function ()
        ---@type UTF8ChunkerInstance
        local chunker = nil
        before_each(function()
            chunker = Chunker.New(5)
        end)
        it("chunks 'ру́сский алфави́т' (15+2 modifier characters) into {'ру́сс', 'кий а', 'лфави', '́т'} with maxChunks 10", function ()
            -- Note that the у́ character is actually two characters in one. So while it looks like 4 characters, they are 5.
            -- The same goes for и́ which puts the ´ in the next chunk because it happened to split there.
            -- It may not make sense reading-wise (I dont know I don't read russian) but it should work for chunking with databanks.
            assert.are_same({'ру́сс', 'кий а', 'лфави', '́т'}, chunker.Chunk('ру́сский алфави́т', 10))
        end)
    end)
    describe("function Dechunk(chunks)", function ()
        it("concatenats {'ру́сс', 'кий а', 'лфави', '́т'} into 'ру́сский алфави́т'", function ()
            -- Dechunking doesn't take minimum length into consideration.
            local chunker = Chunker.New(1)
            assert.are_same('ру́сский алфави́т', chunker.Dechunk({'ру́сс', 'кий а', 'лфави', '́т'}))
        end)
    end)
end)
